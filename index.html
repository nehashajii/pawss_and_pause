<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Prowl</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* --- GLOBAL LAYOUT --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden; /* Prevent scroll bars */
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Disable native touch gestures like pinch/zoom */
            user-select: none; /* Disable text selection */
            -webkit-user-select: none;
        }

        /* --- RESPONSIVE GAME CONTAINER --- */
        #game-container {
            position: relative;
            /* Aspect Ratio Hack: Keeps the game 16:9 regardless of screen size */
            width: 100%;
            max-width: 900px; /* Max size for desktop */
            aspect-ratio: 16 / 9; 
            background: #000;
            box-shadow: 0 0 20px #00ffff;
            border: 2px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Keeps pixel art crisp */
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: auto; /* Allow clicking buttons */
        }

        /* HUD (Heads Up Display) */
        #hud-layer {
            position: absolute;
            top: 10px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none; /* Let clicks pass through to game */
            z-index: 5;
        }

        /* TYPOGRAPHY */
        h1 { 
            font-size: clamp(20px, 4vw, 36px); /* Responsive Font Size */
            color: #0ff; 
            margin-bottom: 10px; 
            line-height: 1.5; 
            text-shadow: 2px 2px #000;
        }
        
        p { 
            color: #aaa; 
            font-size: clamp(8px, 2.5vw, 12px); 
            margin-bottom: 25px; 
            line-height: 1.8; 
            max-width: 600px;
        }

        .hud-text { font-size: clamp(10px, 2vw, 16px); color: #fff; text-shadow: 1px 1px #000; }
        .highlight { color: #0ff; }
        .warning { color: #ff4444; }
        .success { color: #0f0; }

        /* BUTTONS */
        button {
            background: #ff00ff; color: white; border: 3px solid #fff;
            padding: 15px 30px; font-family: inherit; font-size: clamp(12px, 3vw, 16px);
            cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px #ff00ff;
            transition: transform 0.1s;
        }
        button:hover { background: #fff; color: #ff00ff; transform: scale(1.05); }
        button:active { transform: scale(0.95); }

        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="hud-layer">
            <div class="hud-text">LEVEL <span id="lvl-txt" class="highlight">1</span></div>
            <div class="hud-text">GOAL <span id="dist-txt" class="highlight">0%</span></div>
        </div>

        <div id="start-screen" class="overlay">
            <h1>NEON PROWL</h1>
            <p>
                1. HOLD <span class="highlight">SCREEN</span> or <span class="highlight">SPACE</span> to Run.<br>
                2. RELEASE to Stop.<br>
                3. The Drone is <span class="warning">UNPREDICTABLE</span>.<br>
                4. Hide in <span style="color:#cd853f">BOXES</span> to stay safe.
            </p>
            <button id="btn-start">START HEIST</button>
        </div>

        <div id="game-over" class="overlay hidden">
            <h1 class="warning">BUSTED!</h1>
            <p>You moved in the light.</p>
            <button id="btn-retry">TRY AGAIN</button>
        </div>

        <div id="level-complete" class="overlay hidden">
            <h1 class="success">SAFE!</h1>
            <p>Sector Cleared.</p>
            <button id="btn-next">NEXT SECTOR</button>
        </div>

        <canvas id="gameCanvas" width="800" height="450"></canvas>
    </div>

    <script>
        /** * NEON PROWL - Cross-Platform Game Engine
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiStart = document.getElementById('start-screen');
        const uiGameOver = document.getElementById('game-over');
        const uiLevelWin = document.getElementById('level-complete');

        // --- AUDIO SYSTEM (Web Audio API) ---
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) { console.log("Audio not supported"); }
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function sfx(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } 
            else if (type === 'lose') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        // --- LEVEL DATA ---
        const LEVELS = [
            { id: 1, length: 1000, boxes: 3, type: "EASY" },
            { id: 2, length: 1400, boxes: 4, type: "WAIT" },
            { id: 3, length: 1800, boxes: 4, type: "FAST" },
            { id: 4, length: 2200, boxes: 5, type: "CHAOS" },
            { id: 5, length: 3000, boxes: 7, type: "HARDCORE" }
        ];

        // --- GAME STATE ---
        let state = "MENU";
        let lvlIdx = 0;
        let frame = 0;
        let camX = 0;
        let isHolding = false;

        // Entities
        let player = { x: 50, y: 340, w: 30, h: 20, vx: 0, hidden: false };
        let drone = { x: 400, y: 50, targetX: 400, width: 140, state: "IDLE", timer: 0, speed: 0.05 };
        let boxes = [];
        let stars = [];

        // --- SETUP ---
        function initStars() {
            stars = [];
            for(let i=0; i<60; i++) {
                stars.push({
                    x: Math.random() * 800,
                    y: Math.random() * 300,
                    size: Math.random() * 2
                });
            }
        }

        function startGame() {
            initAudio(); // Try to start audio on user click
            lvlIdx = 0;
            loadLevel();
        }

        function nextLevel() {
            lvlIdx++;
            if(lvlIdx >= LEVELS.length) lvlIdx = 0; // Loop game
            loadLevel();
        }

        function loadLevel() {
            let config = LEVELS[lvlIdx];
            
            // UI Handling
            uiStart.classList.add('hidden');
            uiGameOver.classList.add('hidden');
            uiLevelWin.classList.add('hidden');
            
            document.getElementById('lvl-txt').innerText = config.id;

            // Reset Entities
            player.x = 50; player.vx = 0; player.hidden = false;
            camX = 0;
            
            // Reset Drone AI
            drone.x = 400; drone.targetX = 400; drone.state = "THINK"; drone.timer = 0;
            
            // Generate Boxes
            boxes = [];
            for(let i=0; i<config.boxes; i++) {
                boxes.push({
                    x: 300 + Math.random() * (config.length - 400),
                    y: 335, w: 50, h: 30
                });
            }

            initStars();
            state = "PLAYING";
            requestAnimationFrame(gameLoop);
        }

        // --- LOGIC ---
        function updateDrone() {
            let config = LEVELS[lvlIdx];
            let patrolCenter = camX + 400; // Drone stays relative to screen

            // Simple State Machine
            if (drone.state === "THINK") {
                // Pick random spot
                let range = 350;
                let nextX = patrolCenter + (Math.random() * range * 2 - range);
                
                // Clamp
                if (nextX < 0) nextX = 0;
                if (nextX > config.length + 400) nextX = config.length + 400;

                drone.targetX = nextX;
                
                // Decide Speed based on Level Type
                if (config.type === "EASY") drone.speed = 0.04;
                else if (config.type === "FAST") drone.speed = 0.08;
                else if (config.type === "CHAOS") drone.speed = Math.random() * 0.09 + 0.02;
                else drone.speed = 0.05;

                drone.state = "MOVING";

            } else if (drone.state === "MOVING") {
                drone.x += (drone.targetX - drone.x) * drone.speed;
                
                // If reached target
                if (Math.abs(drone.x - drone.targetX) < 10) {
                    drone.state = "WAIT";
                    // Decide Wait Time
                    if (config.type === "WAIT") drone.timer = 100; // Long wait
                    else if (config.type === "CHAOS") drone.timer = Math.random() * 80;
                    else drone.timer = 30;
                }

            } else if (drone.state === "WAIT") {
                drone.timer--;
                if (drone.timer <= 0) drone.state = "THINK";
            }
        }

        function update() {
            frame++;

            // 1. Player Physics
            if (isHolding) player.vx += 0.8;
            else player.vx *= 0.8;
            
            player.vx = Math.min(Math.max(player.vx, 0), 8); // Max speed
            player.x += player.vx;

            // Camera Logic (Follow player)
            let targetCam = player.x - 150;
            if (targetCam < 0) targetCam = 0;
            camX += (targetCam - camX) * 0.1;

            // 2. Box Hiding
            player.hidden = false;
            boxes.forEach(b => {
                let pCenter = player.x + 15;
                let bCenter = b.x + 25;
                if (Math.abs(pCenter - bCenter) < 20) player.hidden = true;
            });

            // 3. Drone Logic
            updateDrone();

            // 4. Detection Logic
            let dist = Math.abs((player.x + 15) - drone.x);
            let inLight = dist < (drone.width / 2);

            if (inLight && !player.hidden) {
                // Caught if moving
                if (Math.abs(player.vx) > 0.5) {
                    gameOver();
                }
            }

            // 5. Win Condition
            let lvlLen = LEVELS[lvlIdx].length;
            if (player.x > lvlLen) {
                state = "WIN";
                sfx('win');
                uiLevelWin.classList.remove('hidden');
            }

            // UI Update
            let pct = Math.floor((player.x / lvlLen) * 100);
            document.getElementById('dist-txt').innerText = Math.min(100, pct) + "%";
        }

        function gameOver() {
            state = "GAMEOVER";
            sfx('lose');
            uiGameOver.classList.remove('hidden');
        }

        // --- DRAWING ---
        function draw() {
            // Clear Screen
            ctx.fillStyle = "#050510";
            ctx.fillRect(0, 0, 800, 450);

            // Stars (Parallax)
            ctx.fillStyle = "#fff";
            stars.forEach(s => {
                let sx = (s.x - camX * 0.2) % 800;
                if(sx < 0) sx += 800;
                ctx.fillRect(sx, s.y, s.size, s.size);
            });

            ctx.save();
            ctx.translate(-camX, 0);

            // Floor
            let len = LEVELS[lvlIdx].length;
            ctx.fillStyle = "#222";
            ctx.fillRect(0, 360, len + 800, 90);
            ctx.strokeStyle = "#555";
            ctx.beginPath(); ctx.moveTo(0,360); ctx.lineTo(len+800, 360); ctx.stroke();

            // Boxes
            boxes.forEach(b => {
                ctx.fillStyle = "#cd853f"; ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.strokeStyle = "#8b4513"; ctx.lineWidth=2; ctx.strokeRect(b.x, b.y, b.w, b.h);
                // "Hide" arrow
                ctx.fillStyle = "rgba(0,0,0,0.4)";
                ctx.beginPath(); ctx.moveTo(b.x+15, b.y+10); ctx.lineTo(b.x+35, b.y+10); ctx.lineTo(b.x+25, b.y+20); ctx.fill();
            });

            // Goal
            ctx.fillStyle = "#0f0"; ctx.fillRect(len, 280, 20, 80);
            ctx.fillText("EXIT", len-10, 270);

            // Player
            if(player.hidden) {
                // Eyes inside box
                let b = boxes.find(box => Math.abs((player.x+15)-(box.x+25)) < 30);
                if(b) {
                    ctx.fillStyle="#fff"; ctx.fillRect(b.x+15, b.y+15, 4, 4); ctx.fillRect(b.x+30, b.y+15, 4, 4);
                }
            } else {
                // Neon Cat
                ctx.fillStyle = "#0ff"; ctx.shadowBlur=15; ctx.shadowColor="#0ff";
                let bounce = Math.abs(Math.sin(frame*0.5)) * (player.vx * 1.5);
                let stretch = player.vx * 3;
                ctx.fillRect(player.x, player.y+bounce, player.w+stretch, player.h-bounce/2);
                ctx.fillRect(player.x+player.w+stretch-5, player.y-10+bounce, 15, 15);
                ctx.shadowBlur=0;
            }

            ctx.restore();

            // Lighting Layer
            drawLight();
        }

        function drawLight() {
            ctx.fillStyle = "rgba(0,0,0,0.85)";
            ctx.fillRect(0, 0, 800, 450);

            ctx.save();
            let dx = drone.x - camX;

            // Cutout
            ctx.globalCompositeOperation = "destination-out";
            ctx.beginPath(); ctx.moveTo(dx, drone.y); ctx.lineTo(dx-drone.width/2, 450); ctx.lineTo(dx+drone.width/2, 450); ctx.fill();

            // Beam Color
            ctx.globalCompositeOperation = "source-over";
            let grad = ctx.createLinearGradient(0, drone.y, 0, 400);
            let dist = Math.abs((player.x+15)-drone.x);
            let inLight = dist < (drone.width/2);
            let caught = (inLight && !player.hidden && player.vx > 0.5);

            grad.addColorStop(0, "rgba(0,0,0,0)");
            grad.addColorStop(1, caught ? "rgba(255,0,0,0.6)" : "rgba(255,255,100,0.2)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.moveTo(dx, drone.y); ctx.lineTo(dx-drone.width/2, 450); ctx.lineTo(dx+drone.width/2, 450); ctx.fill();

            // Drone Body
            ctx.fillStyle = "#333"; ctx.fillRect(dx-20, drone.y-15, 40, 15);
            
            // Drone Eye Status
            if (caught) ctx.fillStyle = "#f00";
            else if (drone.state === "WAIT") ctx.fillStyle = "#ff8800"; // Orange = Waiting/Thinking
            else ctx.fillStyle = "#0ff"; // Blue = Moving

            ctx.fillRect(dx-5, drone.y-5, 10, 5);
            ctx.restore();
        }

        function gameLoop() {
            if(state === "PLAYING") {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        // --- UNIFIED INPUT HANDLER ---
        function setInput(val) { isHolding = val; }

        // Touch
        window.addEventListener('touchstart', (e) => { e.preventDefault(); setInput(true); }, {passive: false});
        window.addEventListener('touchend', (e) => { e.preventDefault(); setInput(false); });
        
        // Mouse
        window.addEventListener('mousedown', () => setInput(true));
        window.addEventListener('mouseup', () => setInput(false));

        // Keyboard
        window.addEventListener('keydown', (e) => { if(e.code === 'Space') setInput(true); });
        window.addEventListener('keyup', (e) => { if(e.code === 'Space') setInput(false); });

        // Button Event Listeners
        document.getElementById('btn-start').addEventListener('click', (e) => { e.stopPropagation(); startGame(); });
        document.getElementById('btn-retry').addEventListener('click', (e) => { e.stopPropagation(); loadLevel(); });
        document.getElementById('btn-next').addEventListener('click', (e) => { e.stopPropagation(); nextLevel(); });

    </script>
</body>
</html>
